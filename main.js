
/*‚≠ê ------------------------------------------------ REGISTRO DE PLUGINS de GSAP ------------------------------------------------------ ‚≠ê*/ 

gsap.registerPlugin(CustomEase);
gsap.registerPlugin(ScrollTrigger);
gsap.registerPlugin(SplitText);
gsap.registerPlugin(ScrambleTextPlugin);
gsap.registerPlugin(DrawSVGPlugin);
gsap.registerPlugin(ScrollToPlugin);


/*‚≠ê ------------------------------------------------------ INTRODUCCI√ìN ---------------------------------------------------------------- ‚≠ê*/

/* Las animaciones de este proyecto est√°n basadas principalmente en ScrollTrigger de GSAP. Cada secci√≥n ocupa el 100% del alto del viewport (100vh) y activa su propia animaci√≥n al entrar en escena. El desplazamiento est√° sincronizado con las animaciones, de modo que no se avanza a la siguiente secci√≥n hasta que la animaci√≥n actual finaliza. De esta forma, consigo un scrolltelling din√°mico, donde es el usuario quien construye la interfaz a medida que avanza, teniendo el control sobre lo que va apareciendo en pantalla y c√≥mo evoluciona la experiencia visual. */


/* ----------------------------------------------------------------------------------------------------------------------------------------- */

//üî∂SECCI√ìN WELCOME - Animaci√≥n de la l√≠nea que crece din√°micamente hasta tocar la parte de abajo de la secci√≥n

const welcome = document.querySelector('#hola');
const line = welcome.querySelector('.line');

const tl00 = gsap.timeline({
  scrollTrigger: {
    trigger: welcome,
    start: "top top", 
    end: "bottom top", 
    scrub: true, 
    pin: true, 
    pinSpacing: true,
  }
});

tl00.fromTo(line,
    { height: '0px' }, 
    { height: '42vh', ease: 'power1.out' } 
);


document.addEventListener("DOMContentLoaded", () => {
  const title = document.querySelector(".fade-in-title");
  
  // Aseg√∫rate de que el DOM est√° cargado antes de a√±adir la clase
  setTimeout(() => {
      title.classList.add("visible"); // A√±ade la clase despu√©s de un peque√±o retraso
  }, 100); // Peque√±o retraso para asegurar que se aplica la transici√≥n
});
/* ----------------------------------------------------------------------------------------------------------------------------------------- */

/*üî∂ TEXTO FIXED - Texto en el margen izquierdo que cambia din√°micamente para indicar la secci√≥n del scrolltelling en la que se encuentra el 
usuario. Pense en hacer un men√∫ al uso pero me acab√© decantando por esto que era m√°s sutil ya que quiero darle m√°s importancia al contenido. */

const sectionText = document.querySelector('.section-id');

// Array con las secciones y sus textos
const sections = [
  { id: "hola", text: "" },
  { id: "reconocimiento", text: "RECONOCIMIENTO DE LA EXPERIENCIA" },
  { id: "sintomas", text: "RECONOCIMIENTO DE LOS S√çNTOMAS" },
  { id: "estrategias", text: "ESTRATEGIAS DE MANEJO" },
  { id: "ayuda", text: "PIDE AYUDA" },
  { id: "cierre", text: "CIERRE"},
];

document.addEventListener("DOMContentLoaded", () => { //Si todo el contenido de la p√°gina no esta cargado, no funcionar√° correctamente
  sections.forEach(({ id, text }) => {
    ScrollTrigger.create({
      trigger: `#${id}`, // Selector por secciones
      start: "top center",
      end: "bottom center", 
      onEnter: () => {
        // Animo la opacidad hacia 0 antes de cambiar el texto
        gsap.to(sectionText, {
          opacity: 0,
          duration: 0.3,
          onComplete: () => {
            // Cambiar el texto despu√©s de que la opacidad llega a 0
            sectionText.textContent = text;
            // Animo la opacidad de vuelta a 1
            gsap.to(sectionText, { opacity: 1, duration: 0.5 });
          }
        });
      },
      onEnterBack: () => {
        // Mismo comportamiento al volver a la secci√≥n
        gsap.to(sectionText, {
          opacity: 0,
          duration: 0.3,
          onComplete: () => {
            sectionText.textContent = text;
            gsap.to(sectionText, { opacity: 1, duration: 0.5 });
          }
        });
      }
    });
});
});
/* ----------------------------------------------------------------------------------------------------------------------------------------- */

/*üî∂ SECCI√ìN 01 - El texto comienza con un color muy clarito. Divido el texto en car√°cteres para poder aplicar letra por letra un color m√°s
oscuro. As√≠ da la sensaci√≥n que el texto se va 'desbloqueando' a medida que el usuario hace scroll.  */

const bloque01 = document.querySelector('.uno');
const texto01 = bloque01.querySelectorAll('p');

// Divido el texto en letras 
const text = new SplitText(texto01, { type: "words" });

const tl01 = gsap.timeline({
  scrollTrigger: {
    trigger: bloque01,
    start: "top top", 
    end: "bottom top", 
    scrub: true, 
    pin: true, 
  }
});

tl01.fromTo(
  text.words, 
  {
    color: "#D4D8D0", // Color inicial clarito
  }, 
  {
    color: "#777E79", // Color final m√°s oscuro
    duration: 1.5,
    stagger: 0.05,
    ease: "power2.out", 
  }
);

/* ----------------------------------------------------------------------------------------------------------------------------------------- */

/*üî∂ SECCI√ìN 02 - ANIMACI√ìN GSAP DRAW SVG. Quer√≠a simular un l√≠o mental para conceptualizar c√≥mo se debe estar sintiendo el usuario
cuando entra a la experiencia.  */

const bloque02 = document.querySelector('.dos');
const h202 = bloque02.querySelector('h2');
const sc02 = bloque02.querySelector('.section-content');

const path = document.querySelector(".morphPath path");

gsap.set(path, {drawSVG: '0%'});

const tl02 = gsap.timeline({
  scrollTrigger: {
    trigger: bloque02, 
    start: "top top", 
    end: "bottom top",
    scrub: true, 
    pin: true,
  }
});

tl02
  .fromTo(h202,
    { opacity: 0, y: 50 }, 
    { opacity: 1, y: 0, duration: 0.5} 
  )
  .fromTo(sc02,
    { opacity: 0, y: 50 }, 
    { opacity: 1, y: 0, duration: 0.5} 
  )
  .to(path, { 
  drawSVG: '40%',
  duration: 2,
  });

/* ----------------------------------------------------------------------------------------------------------------------------------------- */

/*üî∂ SECCI√ìN 03.01 - Animaci√≥n del carrusel horizontal. Se trata de un carrusel con items. Cuando el usaurio entra en la secci√≥n 03, el scroll
pasa de ser vertical a ser horrizontal para recorrer todos los items hasta el final. Este cambio de scroll lo he 'forzado' mediante un translateX
del carrusel. El overflow queda oculto por el contenedor del carrusel.  */

const bloque03 = document.querySelector('.tres');
const carousel = bloque03.querySelector('.carousel');
const h203 = bloque03.querySelector('h2');
const sc03 = bloque03.querySelector('.section-content');

const getTranslateXValue = () => {
  return window.innerWidth < 1024 ? '-585vw' : '-195vw'; // Usar -100vw para m√≥viles y -195vw para otros
};

const tl03 = gsap.timeline({
    scrollTrigger: {
      trigger: bloque03,
      start: "top top",
      end: "bottom top",
      scrub: 5,
      pin: true,
    },
  });

  tl03
  .fromTo(h203,
    { opacity: 0, y: 50 }, 
    { opacity: 1, y: 0, duration: 0.8}
  )
  .fromTo(sc03,
    { opacity: 0, y: 50 }, 
    { opacity: 1, y: 0, duration: 0.8} 
  )
  .fromTo(carousel,
    {opacity: 0},
    {opacity: 1, duration: 0.8}
  )
  .fromTo(carousel, 
    {x:'0px'}, 
    {x: getTranslateXValue(),
     ease: "power2.inOut", // Suaviza el desplazamiento
     duration: 100, // Hace que el desplazamiento sea menos brusco (una especie de scroll smooth)
    } 
  )
  .fromTo(carousel,
    {opacity: 1},
    {opacity: 0, duration: 0.8}
  )
  .to({}, {duration: 2});

/*üî∂ SECCI√ìN 03.02 - Control de la aparici√≥n de la informaci√≥n en los items del carrusel. Cada s√≠ntoma contiene una descrici√≥n algo extensa, la cual he decidido ocultar (solo se muestra t√≠tulo y peque√±a descripci√≥n) Cuando el usuario hace click sobre un s√≠ntoma puede desplegar la informaci√≥n. Esto lo hago mediante el control de los items 'active' del carrusel. Solo puede haber 1 item abierto, hay una funci√≥n que verifica si hay algun item abierto para cerrarlo antes de abirir otro */


const carouselItems = document.querySelectorAll('.carousel-item');

carouselItems.forEach(item => {
  item.addEventListener('click', () => {
    // Verifico si el elemento ya est√° activo
    const isActive = item.classList.contains('active');

    // Cierro todos los items del carrusel
    carouselItems.forEach(innerItem => {
      innerItem.classList.remove('active');
    });

    // Si no estaba activo, lo activamo
    if (!isActive) {
      item.classList.add('active');
    }
  });
});


/*üî∂ SECCI√ìN 03.03 - Custom mouse para cuando se hace hover sobre un item del carrusel. Para que el usaurio sepa que puede desplegar m√°s informaci√≥n en los items, he decidido hacer que el mouse al hacer hover sobre un item se convierta en un c√≠rculo con el s√≠mbolo + */

carouselItems.forEach(item => {
    let circlePlus;
    
    const isDesktop = () => window.innerWidth >= 1024;

    item.addEventListener('mouseenter', function() {
        if (!isDesktop()) return;

        // Crear un nuevo elemento div para el c√≠rculo
        circlePlus = document.createElement('div');
        circlePlus.classList.add('circle-plus');
       
        circlePlus.innerText = "+"; // El signo +
        

        item.appendChild(circlePlus);

        // Activar la animaci√≥n de aparici√≥n
        setTimeout(() => {
            circlePlus.style.transform = 'scale(1.3)';
            circlePlus.style.opacity = '1';
        }, 10);
    });

    // Mover el c√≠rculo con el rat√≥n
    item.addEventListener('mousemove', function(e) {
      if (!isDesktop() || !circlePlus) return;

      const mouseX = e.clientX; 
      const mouseY = e.clientY; 
      
      const offsetX = 15;  
      const offsetY = 15; 

      // Posicionar el c√≠rculo en las coordenadas del rat√≥n
      circlePlus.style.left = `${mouseX - item.getBoundingClientRect().left - offsetX}px`;
      circlePlus.style.top = `${mouseY - item.getBoundingClientRect().top - offsetY}px`;

      if( item.classList.contains('active')) {
        circlePlus.innerHTML = '<span class="inner-text">_</span>';

      }else {
        circlePlus.innerText = "+"; // El signo +
      }
    });

    // Eliminar el c√≠rculo cuando el mouse sale
    item.addEventListener('mouseleave', function() {
      if (!isDesktop() || !circlePlus) return;
            // Iniciar la animaci√≥n de desaparici√≥n
            circlePlus.style.transform = 'scale(0)';
            circlePlus.style.opacity = '0';

            setTimeout(() => {
                circlePlus.remove();
            }, 300); 
        
    });
});

/* ----------------------------------------------------------------------------------------------------------------------------------------- */

/*üî∂ SECCI√ìN 04 - Cambio de colores del root en la secci√≥n 4 (para hacer una especie de darkmode, as√≠ la transici√≥n entre secciones queda m√°s limpia). Tambi√©n una peque√±a animaci√≥n de los textos para que aparezcan m√°s suavemente. */


const bloque04 = document.querySelector(".cuatro");
const h204 = bloque04.querySelector('h2');
const sc04 = bloque04.querySelector('.section-content');

const tl04 = gsap.timeline({
  scrollTrigger: {
      trigger: bloque04, 
      start: "top top",   
      end: "bottom top",  
      scrub: true,
      pin: true,  
     
      onEnter: () => {
          // Cambiar colores al entrar en la secci√≥n "fin"
          gsap.to(root, { 
              "--color-1": "#F9F5F0", // Cambiar a color-3
              "--color-3": "#777E79", // Cambiar a color-1
              duration: 0.5 
          });
      },
      onEnterBack: () => {
          // Revertir colores al salir de la secci√≥n "fin" hacia atr√°s
          gsap.to(root, { 
              "--color-1": "#777E79", // Volver a color-1
              "--color-3": "#F9F5F0", // Volver a color-3
              duration: 0.5 
          });
      },
      onLeaveBack: () => {
          // Revertir colores al salir de la secci√≥n "fin" hacia atr√°s
          gsap.to(root, { 
              "--color-1": "#777E79", // Volver a color-1
              "--color-3": "#F9F5F0", // Volver a color-3
              duration: 0.2 
          });
      },
      onLeave: () => {
          // Volver a los colores originales al salir de la secci√≥n
          gsap.to(root, { 
              "--color-1": "#777E79", // Volver a color-1
              "--color-3": "#F9F5F0", // Volver a color-3
              duration: 0.5 
          });
      }
  }
});

tl04.fromTo(h204,
  { opacity: 0, y: 50 }, 
  { opacity: 1, y: 0, duration: 0.5}
)
.fromTo(sc04,
  { opacity: 0, y: 50 }, 
  { opacity: 1, y: 0, duration: 0.5}, 
)
.to({}, {duration: 2}); //He a√±adido una peque√±a pausa al terminar proque si no pasaba de secci√≥n muy r√°pido

/* ----------------------------------------------------------------------------------------------------------------------------------------- */

/*üî∂ SECCI√ìN 05 - Animaci√≥n secci√≥n ENF√ìCATE. Texto que inicialmente esta desenfocado y pasa a enfocarse mediente la propiedad blur de CSS */

const bloque05 = document.querySelector('.cinco');
const enfocate = bloque05.querySelector('.enfocate');

const tl05 = gsap.timeline({
  scrollTrigger: {
    trigger: bloque05, 
    start: "top top",
    end: "bottom top",   
    scrub: true,
    pin: true, 
  },
});

tl05.fromTo(
  enfocate, 
  { filter: "blur(10px)" },  // Estado inicial
  { filter: "blur(0px)" } // Estado final
)
.to({}, {duration: 2}); //He a√±adido una peque√±a pausa al terminar proque si no pasaba de secci√≥n muy r√°pido

/* ----------------------------------------------------------------------------------------------------------------------------------------- */

/*üî∂ SECCI√ìN 06 - Animaci√≥n secci√≥n RESPIRA. Son 4 c√≠rculos concentricos que simulan una inspiraci√≥n para complementar el texto */

const bloque06 = document.querySelector('.seis');
const bcir = bloque06.querySelectorAll('.breath .circle');

const tl06 = gsap.timeline({
  scrollTrigger: {
    trigger: bloque06, 
    start: "top top",
    end: "bottom top",   
    scrub: 1.5,
    pin: true, 
  },
});

//Los c√≠rculos crecen uno detr√°s de otro y tama√±os cada vez m√°s grandes para simular una inspiraci√≥n, como los c√≠rculos de la experiencia de respiraci√≥n

tl06
.to(bcir[0], { 
  width: "25vw", 
  height: "25vw", 
  opacity: 1, 
  duration: 1,
  ease: "power1.out",
})
.to(bcir[1], { 
  width: "50vw", 
  height: "50vw", 
  opacity: 1, 
  duration: 1,
  ease: "power1.out",
}, "+=0.5")  
.to(bcir[2], { 
  width: "75vw", 
  height: "75vw", 
  opacity: 1, 
  duration: 1,
  ease: "power1.out",
}, "+=0.5") 
.to(bcir[3], { 
  width: "100vw", 
  height: "100vw", 
  opacity: 1, 
  duration: 1,
  ease: "power1.out",
}, "+=0.5")
.to({}, {duration: 3}); //He a√±adido una peque√±a pausa al terminar proque si no pasaba de secci√≥n muy r√°pido 

/* ----------------------------------------------------------------------------------------------------------------------------------------- */

/*üî∂ SECCI√ìN 07 - Es una animaci√≥n para mostrar los diferentes tipos de ayuda que puede tener el usaurio. Al principio aparece un solo c√≠rculo 
(el usuario est√° solo) luego aparece un mensaje que pone que puede pedir ayuda de la forma m√°s c√≥moda para √©l. Y los c√≠rculos de ayuda se despliegan para cambiar la situacion (el usauario ya no esta solo) */

const bloque07 = document.querySelector('.siete');
const circles = bloque07.querySelectorAll('.help-item');
const sietest = bloque07.querySelector(".section-content");
const tex = bloque07.querySelectorAll(".help-text");

const tl07 = gsap.timeline({
  scrollTrigger: {
    trigger: bloque07, 
    start: "top top", 
    end: "bottom top",
    scrub: 2,
    pin: true, 
  },
});

//El texto empieza oculto y desplazado y tiene una peque√±a animaci√≥n para aparecer
tl07
  .fromTo(sietest,
    { opacity: 0, y: 50 }, 
    { opacity: 1, y: 0, duration: 1} 
  );

  // Funci√≥n para detectar el tama√±o de la pantalla
  function getDeviceSize() {
    const width = window.innerWidth;
  
    if (width <= 768) {
      return "mobile"; // Para pantallas de m√≥vil (ancho <= 768px)
    } else if (width <= 1024) {
      return "tablet"; // Para pantallas de tablet (768px < ancho <= 1024px)
    } else {
      return "desktop"; // Para pantallas de escritorio (ancho > 1024px)
    }
  }
  

// Establecer los valores diferentes dependiendo del tama√±o de la pantalla
function setCircleValues() {
  const device = getDeviceSize();

  // Establecer los valores de posici√≥n y tama√±o de cada c√≠rculo seg√∫n el dispositivo
  if (device === "mobile") {
    return {
      circle1: { width: "18vh", height: "18vh", x: "-15vw", y: "-56vh" },
      circle2: { x: "-70vw", y: "-11vh" },
      circle3: { width: "27vh", height: "27vh", x: "-52vw", y: "-38vh" },
      circle4: { width: "11vh", height: "11vh", x: "-70vw", y: "-55vh" },
    };
  } else if (device === "tablet") {
    console.log("tablet");
    return {
      circle1: { width: "28vh", height: "28vh", x: "0vw", y: "-35vh" },
      circle2: { x: "-55vw", y: "2vh" },
      circle3: { width: "25vh", height: "25vh", x: "-35vw", y: "-23vh" },
      circle4: { width: "14vh", height: "14vh", x: "-60vw", y: "-38vh" },
    };
  } else { // Para escritorio (desktop)
    return {
      circle1: { width: "26vh", height: "26vh", x: "10vw", y: "-45vh" },
      circle2: { x: "-40vw", y: "5vh" },
      circle3: { width: "23vh", height: "23vh", x: "-20vw", y: "-20vh" },
      circle4: { width: "16vh", height: "16vh", x: "-65vw", y: "-10vh" },
    };
  }
}

// Recuperar los valores para los c√≠rculos dependiendo de cada dispositivo
const circleValues = setCircleValues();

//Los c√≠rculos se colocan en sus lugares. Algunos cambian tambi√©n de tama√±o
tl07
  .to(circles[1], { width: circleValues.circle1.width, height: circleValues.circle1.height, x: circleValues.circle1.x, y: circleValues.circle1.y, duration: 1 }, "<")
  .to(circles[2], { x: circleValues.circle2.x, y: circleValues.circle2.y, duration: 1 }, "<")
  .to(circles[3], { width: circleValues.circle3.width, height: circleValues.circle3.height, x: circleValues.circle3.x, y: circleValues.circle3.y, duration: 1 }, "<")
  .to(circles[4], { width: circleValues.circle4.width, height: circleValues.circle4.height, x: circleValues.circle4.x, y: circleValues.circle4.y, duration: 1 }, "<")
  .fromTo(tex, { opacity: 0, duration: 1 },{ opacity: 1, duration: 1 }, "<")
  .to({}, {duration: 2}); // Pausa adicional

/* ----------------------------------------------------------------------------------------------------------------------------------------- */

/*üî∂ SECCI√ìN 08 - Animaci√≥n que hace peque√±a la palabra ansiedad para simbolizar que esta desaparece */

const bloque08 = document.querySelector('.ocho');
const ansiedad = bloque08.querySelector('.ansiedad');
const mensaje = bloque08.querySelector('.mensaje');

// Determinar los valores de 'y' seg√∫n el tama√±o de pantalla
const getYValueForAnsiedad = () => (window.innerWidth < 1024 ? -10 : -80);
const getYValueForMensaje = () => (window.innerWidth < 1024 ? -10 : -120);

const tl08 = gsap.timeline({
  scrollTrigger: {
    trigger: bloque08,
    start: "top top",
    end: "bottom top",
    scrub: true,
    pin: true,
  },
});

// Reducir el tama√±o de "ANSIEDAD"
tl08.to(ansiedad, {
  scale: 0.1,
  y: getYValueForAnsiedad(), // Usar el valor din√°mico para 'y'
  duration: 3,
  ease: "power3.out",
});

// Aparici√≥n del mensaje final
tl08.to(mensaje, {
  opacity: 1, // Cambia opacidad de 0 a 1
  y: getYValueForMensaje(), // Usar el valor din√°mico para 'y'
  duration: 2,
  ease: "power2.inOut",
})
.to({}, {duration: 3}); //He a√±adido una peque√±a pausa al terminar proque si no pasaba de secci√≥n muy r√°pido 


/* ----------------------------------------------------------------------------------------------------------------------------------------- */

/*üî∂ SECCI√ìN 09 - TRANSICI√ìN DE COLOR. Quer√≠a que hUbiera una transici√≥n entre fondo blanco y fondo verde oscuro. Para que esta transici√≥n fuera suave he decidido invertir los colores del root as√≠ cambian todos los colores (es similar a una transici√≥n de dark mode) */

const bloque09 = document.querySelector(".fin");


const root = document.documentElement;

const tl09 = gsap.timeline({
    scrollTrigger: {
        trigger: bloque09, 
        start: "top 80%",   
        end: "bottom 20%",  
        scrub: true,       
        onEnter: () => {
            // Cambiar colores al entrar en la secci√≥n "fin"
            gsap.to(root, { 
                "--color-1": "#F9F5F0", 
                "--color-3": "#777E79", 
                duration: 0.5 
            });
        },
        onEnterBack: () => {
            // Revertir colores al salir de la secci√≥n "fin" hacia atr√°s
            gsap.to(root, { 
                "--color-1": "#777E79",
                "--color-3": "#F9F5F0", 
                duration: 0.5 
            });
        },
        onLeaveBack: () => {
            // Revertir colores al salir de la secci√≥n "fin" hacia atr√°s
            gsap.to(root, { 
                "--color-1": "#777E79", 
                "--color-3": "#F9F5F0",
                duration: 0.2 
            });
        },
        onLeave: () => {
            // Volver a los colores originales al salir de la secci√≥n
            gsap.to(root, { 
                "--color-1": "#777E79", 
                "--color-3": "#F9F5F0", 
                duration: 0.5 
            });
        }
    }
});

/* ----------------------------------------------------------------------------------------------------------------------------------------- */

/*üî∂ SECCI√ìN FINAL - Animaci√≥n para el bot√≥n de volver a la experiencia de respiraci√≥n */

const volverBtn = document.querySelector('.volver-btn');
const emoji = volverBtn.querySelector('.emoji');
const texto = volverBtn.querySelector('.texto');

// Creamos una timeline con GSAP
const tl10 = gsap.timeline({
  scrollTrigger: {
    trigger: volverBtn, // El bot√≥n se anima al llegar a su secci√≥n
    start: "top bottom", // Inicia cuando el bot√≥n entra al centro de la pantalla
  
    toggleActions: "restart pause reverse pause",
  }
});

// Configuramos la animaci√≥n
tl10
  .to(volverBtn, {
    duration: 1,
    width: "200px", // Aumenta el ancho del bot√≥n
    borderRadius: "25px", // Cambia de circular a un bot√≥n con bordes redondeados
    ease: "power1.out",
  })
  .to(emoji, {
    duration: 0.5,
    opacity: 0, // Oculta el emoji
    ease: "power1.out",
  }, "-=0.5") // Se solapan las animaciones para mayor fluidez
  .to(texto, {
    duration: 0.5,
    opacity: 1, // Muestra el texto
    ease: "power1.out",
  });


